// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// User & Authentication Models
model User {
  id            String    @id @default(cuid())
  name          String?
  nameArabic    String?
  email         String    @unique
  emailVerified DateTime?
  phone         String?   @unique
  image         String?
  password      String?
  role          UserRole  @default(USER)
  isActive      Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts           Account[]
  sessions           Session[]
  stores             UserStore[]
  createdCustomers   Customer[]           @relation("CreatedBy")
  managedSuppliers   Supplier[]           @relation("CreatedBy")
  createdProducts    Product[]            @relation("CreatedBy")
  createdOrders      Order[]              @relation("CreatedBy")
  processedPayments  Payment[]            @relation("ProcessedBy")
  createdStores      Store[]              @relation("CreatedBy")
  createdTransfers   Transfer[]           @relation("CreatedBy")
  createdMovements   StockMovement[]      @relation("CreatedBy")
  supervisedBatches  ProductionBatch[]    @relation("SupervisedBy")
  operatedStages     ProcessingStage[]    @relation("OperatedBy")

  @@map("users")
}

model UserStore {
  id      String @id @default(cuid())
  userId  String
  storeId String
  role    StoreRole

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([userId, storeId])
  @@map("user_stores")
}

// Core Models
model Customer {
  id              String       @id @default(cuid())
  name            String
  nameArabic      String?
  email           String?      @unique
  phone           String?      @unique
  customerType    CustomerType @default(INDIVIDUAL)
  isVIP           Boolean      @default(false)
  dateOfBirth     DateTime?
  address         String?
  emirate         String?
  city            String?
  loyaltyPoints   Int          @default(0)
  totalSpent      Decimal      @default(0) @db.Decimal(10, 2)
  lastPurchase    DateTime?
  notes           String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  createdById     String

  // Relations
  createdBy User      @relation("CreatedBy", fields: [createdById], references: [id])
  orders    Order[]
  payments  Payment[]

  @@map("customers")
}

model Supplier {
  id          String   @id @default(cuid())
  name        String
  nameArabic  String?
  email       String?  @unique
  phone       String?
  address     String?
  contactPerson String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String

  // Relations
  createdBy    User      @relation("CreatedBy", fields: [createdById], references: [id])
  products     Product[]
  purchaseOrders PurchaseOrder[]

  @@map("suppliers")
}

model Category {
  id          String    @id @default(cuid())
  name        String
  nameArabic  String?
  description String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  // Relations
  products Product[]

  @@map("categories")
}

model Brand {
  id          String    @id @default(cuid())
  name        String
  nameArabic  String?
  description String?
  logoUrl     String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  // Relations
  products Product[]

  @@map("brands")
}

model Product {
  id            String      @id @default(cuid())
  name          String
  nameArabic    String?
  description   String?
  sku           String      @unique
  categoryId    String
  brandId       String?
  supplierId    String?
  type          ProductType @default(FINISHED)
  unit          ProductUnit @default(PIECE)
  unitPrice     Decimal     @db.Decimal(10, 2)
  costPrice     Decimal?    @db.Decimal(10, 2)
  stockQuantity Int         @default(0)
  minStock      Int         @default(0)
  maxStock      Int?
  isActive      Boolean     @default(true)
  hasVariants   Boolean     @default(false)
  imageUrl      String?
  notes         String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  createdById   String

  // Relations
  category       Category           @relation(fields: [categoryId], references: [id])
  brand          Brand?             @relation(fields: [brandId], references: [id])
  supplier       Supplier?          @relation(fields: [supplierId], references: [id])
  createdBy      User               @relation("CreatedBy", fields: [createdById], references: [id])
  orderItems     OrderItem[]
  stockMovements StockMovement[]
  recipes        Recipe[]
  recipeItems    RecipeItem[]
  productionBatches ProductionBatch[]
  storeInventory StoreInventory[]

  @@map("products")
}

// Store Management Models
model Store {
  id          String     @id @default(cuid())
  name        String
  nameArabic  String?
  code        String     @unique
  address     String
  emirate     String
  city        String
  phone       String?
  email       String?
  managerId   String?
  isActive    Boolean    @default(true)
  openingTime String?
  closingTime String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdById String

  // Relations
  createdBy       User             @relation("CreatedBy", fields: [createdById], references: [id])
  userStores      UserStore[]
  orders          Order[]
  inventory       StoreInventory[]
  fromTransfers   Transfer[]       @relation("FromStore")
  toTransfers     Transfer[]       @relation("ToStore")
  stockMovements  StockMovement[]

  @@map("stores")
}

model StoreInventory {
  id            String   @id @default(cuid())
  storeId       String
  productId     String
  quantity      Int      @default(0)
  reservedQty   Int      @default(0)
  lastUpdated   DateTime @default(now())

  // Relations
  store   Store   @relation(fields: [storeId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([storeId, productId])
  @@map("store_inventory")
}

model Transfer {
  id            String        @id @default(cuid())
  fromStoreId   String
  toStoreId     String
  status        TransferStatus @default(PENDING)
  notes         String?
  totalItems    Int           @default(0)
  requestedAt   DateTime      @default(now())
  approvedAt    DateTime?
  shippedAt     DateTime?
  receivedAt    DateTime?
  createdById   String

  // Relations
  fromStore     Store         @relation("FromStore", fields: [fromStoreId], references: [id])
  toStore       Store         @relation("ToStore", fields: [toStoreId], references: [id])
  createdBy     User          @relation("CreatedBy", fields: [createdById], references: [id])
  items         TransferItem[]

  @@map("transfers")
}

model TransferItem {
  id          String @id @default(cuid())
  transferId  String
  productId   String
  quantity    Int
  receivedQty Int?

  // Relations
  transfer Transfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id])

  @@map("transfer_items")
}

// Sales & Order Models
model Order {
  id           String      @id @default(cuid())
  orderNumber  String      @unique
  customerId   String?
  storeId      String
  status       OrderStatus @default(PENDING)
  totalAmount  Decimal     @db.Decimal(10, 2)
  vatAmount    Decimal     @default(0) @db.Decimal(10, 2)
  grandTotal   Decimal     @db.Decimal(10, 2)
  paymentStatus PaymentStatus @default(PENDING)
  notes        String?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  createdById  String

  // Relations
  customer  Customer?   @relation(fields: [customerId], references: [id])
  store     Store       @relation(fields: [storeId], references: [id])
  createdBy User        @relation("CreatedBy", fields: [createdById], references: [id])
  items     OrderItem[]
  payments  Payment[]

  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  productId String
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(10, 2)

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@map("order_items")
}

model Payment {
  id            String        @id @default(cuid())
  orderId       String?
  customerId    String?
  amount        Decimal       @db.Decimal(10, 2)
  method        PaymentMethod
  status        PaymentStatus @default(PENDING)
  reference     String?
  notes         String?
  createdAt     DateTime      @default(now())
  processedById String

  // Relations
  order       Order?    @relation(fields: [orderId], references: [id])
  customer    Customer? @relation(fields: [customerId], references: [id])
  processedBy User      @relation("ProcessedBy", fields: [processedById], references: [id])

  @@map("payments")
}

// Purchase Order Models
model PurchaseOrder {
  id           String             @id @default(cuid())
  orderNumber  String             @unique
  supplierId   String
  status       PurchaseOrderStatus @default(PENDING)
  totalAmount  Decimal            @db.Decimal(10, 2)
  notes        String?
  orderDate    DateTime           @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relations
  supplier Supplier            @relation(fields: [supplierId], references: [id])
  items    PurchaseOrderItem[]

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String  @id @default(cuid())
  purchaseOrderId String
  productId       String
  quantity        Int
  unitPrice       Decimal @db.Decimal(10, 2)
  receivedQty     Int     @default(0)

  // Relations
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id])

  @@map("purchase_order_items")
}

// Production Models
model Recipe {
  id            String    @id @default(cuid())
  name          String
  nameArabic    String?
  description   String?
  category      String?
  version       String    @default("1.0")
  isActive      Boolean   @default(true)
  yieldQuantity Decimal   @db.Decimal(10, 3)
  yieldUnit     String
  costPerUnit   Decimal?  @db.Decimal(10, 2)
  instructions  String?
  notes         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  ingredients       RecipeIngredient[]
  versions          RecipeVersion[]
  boms              BOM[]
  productionBatches ProductionBatch[]

  @@map("recipes")
}

model RecipeIngredient {
  id         String  @id @default(cuid())
  recipeId   String
  materialId String
  quantity   Decimal @db.Decimal(10, 3)
  unit       String
  percentage Decimal? @db.Decimal(5, 2)
  isOptional Boolean @default(false)
  notes      String?
  order      Int     @default(0)

  // Relations
  recipe   Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id])

  @@map("recipe_ingredients")
}

model RecipeVersion {
  id        String   @id @default(cuid())
  recipeId  String
  version   String
  changes   String?
  createdAt DateTime @default(now())
  createdBy String?

  // Relations
  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@map("recipe_versions")
}

model Material {
  id           String   @id @default(cuid())
  name         String
  description  String?
  sku          String   @unique
  categoryId   String
  unitOfMeasure String
  costPerUnit  Decimal  @db.Decimal(10, 2)
  currentStock Decimal  @db.Decimal(10, 3)
  minimumStock Decimal  @db.Decimal(10, 3)
  maximumStock Decimal? @db.Decimal(10, 3)
  supplier     String?
  supplierPrice Decimal? @db.Decimal(10, 2)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  category          Category           @relation(fields: [categoryId], references: [id])
  recipeIngredients RecipeIngredient[]
  bomItems          BOMItem[]
  productionInputs  ProductionInput[]
  productionOutputs ProductionOutput[]
  stockMovements    StockMovement[]
  wastageRecords    WastageRecord[]

  @@map("materials")
}

model BOM {
  id        String   @id @default(cuid())
  recipeId  String
  name      String
  version   String
  isActive  Boolean  @default(false)
  totalCost Decimal  @db.Decimal(10, 2)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recipe Recipe    @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  items  BOMItem[]

  @@map("boms")
}

model BOMItem {
  id         String  @id @default(cuid())
  bomId      String
  materialId String
  quantity   Decimal @db.Decimal(10, 3)
  unit       String
  unitCost   Decimal @db.Decimal(10, 2)
  totalCost  Decimal @db.Decimal(10, 2)
  notes      String?

  // Relations
  bom      BOM      @relation(fields: [bomId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id])

  @@map("bom_items")
}

model ProductionBatch {
  id                String           @id @default(cuid())
  batchNumber       String           @unique
  recipeId          String?
  plannedQuantity   Decimal          @db.Decimal(10, 3)
  actualQuantity    Decimal?         @db.Decimal(10, 3)
  unit              String
  status            ProductionStatus @default(PLANNED)
  startDate         DateTime
  endDate           DateTime?
  agingStartDate    DateTime?
  agingEndDate      DateTime?
  agingDays         Int?
  temperature       Decimal?         @db.Decimal(5, 2)
  humidity          Decimal?         @db.Decimal(5, 2)
  notes             String?
  supervisorId      String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  recipe          Recipe?            @relation(fields: [recipeId], references: [id])
  supervisor      User?              @relation("SupervisedBy", fields: [supervisorId], references: [id])
  inputs          ProductionInput[]
  outputs         ProductionOutput[]
  qualityControls QualityControl[]
  wastageRecords  WastageRecord[]
  processingStages ProcessingStage[]

  @@map("production_batches")
}

model ProductionInput {
  id               String   @id @default(cuid())
  batchId          String
  materialId       String
  plannedQuantity  Decimal  @db.Decimal(10, 3)
  actualQuantity   Decimal? @db.Decimal(10, 3)
  unit             String
  costPerUnit      Decimal  @db.Decimal(10, 2)
  totalCost        Decimal  @db.Decimal(10, 2)
  notes            String?
  createdAt        DateTime @default(now())

  // Relations
  batch    ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material        @relation(fields: [materialId], references: [id])

  @@map("production_inputs")
}

model ProductionOutput {
  id          String   @id @default(cuid())
  batchId     String
  materialId  String
  quantity    Decimal  @db.Decimal(10, 3)
  unit        String
  costPerUnit Decimal  @db.Decimal(10, 2)
  totalCost   Decimal  @db.Decimal(10, 2)
  notes       String?
  createdAt   DateTime @default(now())

  // Relations
  batch    ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material        @relation(fields: [materialId], references: [id])

  @@map("production_outputs")
}

model QualityControl {
  id        String        @id @default(cuid())
  batchId   String
  testType  String
  testDate  DateTime
  result    QualityResult @default(PENDING)
  score     Decimal?      @db.Decimal(3, 1)
  notes     String?
  testedBy  String?
  images    String?       // JSON array of image URLs
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Relations
  batch ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@map("quality_controls")
}

model WastageRecord {
  id         String   @id @default(cuid())
  batchId    String?
  materialId String?
  quantity   Decimal  @db.Decimal(10, 3)
  unit       String
  reason     String
  cost       Decimal  @db.Decimal(10, 2)
  recordedAt DateTime
  notes      String?
  createdAt  DateTime @default(now())

  // Relations
  batch    ProductionBatch? @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material?        @relation(fields: [materialId], references: [id])

  @@map("wastage_records")
}

model ProcessingStage {
  id                String      @id @default(cuid())
  productionBatchId String
  stageName         String
  description       String?
  order             Int         @default(0)
  status            StageStatus @default(PENDING)
  startedAt         DateTime?
  completedAt       DateTime?
  temperature       Decimal?    @db.Decimal(5, 2)
  humidity          Decimal?    @db.Decimal(5, 2)
  duration          Int?        // in minutes
  instructions      String?
  notes             String?
  operatorId        String?
  isRequired        Boolean     @default(true)
  isIoTEnabled      Boolean     @default(false)
  sensorData        String?     // JSON for IoT sensor readings

  // Relations
  productionBatch ProductionBatch @relation(fields: [productionBatchId], references: [id], onDelete: Cascade)
  operator        User?           @relation("OperatedBy", fields: [operatorId], references: [id])

  @@map("processing_stages")
}

// Inventory Management
model StockMovement {
  id            String            @id @default(cuid())
  productId     String
  storeId       String?
  movementType  StockMovementType
  quantity      Int
  referenceType String?           // ORDER, ADJUSTMENT, TRANSFER, etc.
  referenceId   String?
  notes         String?
  createdAt     DateTime          @default(now())
  createdById   String

  // Relations
  product   Product @relation(fields: [productId], references: [id])
  store     Store?  @relation(fields: [storeId], references: [id])
  createdBy User    @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("stock_movements")
}

// Enums
enum UserRole {
  OWNER
  MANAGER
  ACCOUNTANT
  SALES_STAFF
  INVENTORY_STAFF
  USER
}

enum StoreRole {
  MANAGER
  ASSISTANT_MANAGER
  SALES_STAFF
  INVENTORY_STAFF
}

enum CustomerType {
  INDIVIDUAL
  CORPORATE
}

enum ProductType {
  RAW_MATERIAL
  SEMI_FINISHED
  FINISHED
}

enum ProductUnit {
  PIECE
  GRAM
  KILOGRAM
  TOLA
  MILLILITER
  LITER
  BOTTLE
  SET
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
}

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  DIGITAL_WALLET
  CHEQUE
}

enum PurchaseOrderStatus {
  PENDING
  CONFIRMED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

enum TransferStatus {
  PENDING
  APPROVED
  SHIPPED
  RECEIVED
  CANCELLED
}

enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  AGING
  QUALITY_CHECK
  COMPLETED
  CANCELLED
  ON_HOLD
}

enum QualityResult {
  PENDING
  PASS
  FAIL
  RETEST_REQUIRED
}

enum StageStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

enum StockMovementType {
  IN
  OUT
  ADJUSTMENT
  TRANSFER
}