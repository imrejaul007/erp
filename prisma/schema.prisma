// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// User & Authentication Models
model User {
  id            String    @id @default(cuid())
  name          String?
  nameArabic    String?
  email         String    @unique
  emailVerified DateTime?
  phone         String?   @unique
  image         String?
  password      String?
  role          UserRole  @default(USER)
  isActive      Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts           Account[]
  sessions           Session[]
  stores             UserStore[]
  createdCustomers   Customer[]           @relation("CreatedBy")
  managedSuppliers   Supplier[]           @relation("CreatedBy")
  createdProducts    Product[]            @relation("CreatedBy")
  createdOrders      Order[]              @relation("CreatedBy")
  processedPayments  Payment[]            @relation("ProcessedBy")
  createdStores      Store[]              @relation("CreatedBy")
  createdTransfers   Transfer[]           @relation("CreatedBy")
  createdMovements   StockMovement[]      @relation("CreatedBy")
  supervisedBatches  ProductionBatch[]    @relation("SupervisedBy")
  operatedStages     ProcessingStage[]    @relation("OperatedBy")
  assignedComplaints CustomerComplaint[]  @relation("AssignedComplaints")

  @@map("users")
}

model UserStore {
  id      String @id @default(cuid())
  userId  String
  storeId String
  role    StoreRole

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)

  @@unique([userId, storeId])
  @@map("user_stores")
}

// Core Models
model Customer {
  id              String       @id @default(cuid())
  name            String
  nameArabic      String?
  email           String?      @unique
  phone           String?      @unique
  customerType    CustomerType @default(INDIVIDUAL)
  isVIP           Boolean      @default(false)
  dateOfBirth     DateTime?
  address         String?
  emirate         String?
  city            String?
  loyaltyPoints   Int          @default(0)
  totalSpent      Decimal      @default(0) @db.Decimal(10, 2)
  lastPurchase    DateTime?
  notes           String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  createdById     String

  // Relations
  createdBy           User                      @relation("CreatedBy", fields: [createdById], references: [id])
  orders              Order[]
  payments            Payment[]
  segments            CustomerSegmentMember[]
  complaints          CustomerComplaint[]
  loyaltyTransactions LoyaltyPointsTransaction[]
  vipEvents           VIPEventAttendee[]
  campaignResponses   CampaignResponse[]

  @@map("customers")
}

model Supplier {
  id          String   @id @default(cuid())
  name        String
  nameArabic  String?
  email       String?  @unique
  phone       String?
  address     String?
  contactPerson String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String

  // Relations
  createdBy    User      @relation("CreatedBy", fields: [createdById], references: [id])
  products     Product[]
  purchaseOrders PurchaseOrder[]

  @@map("suppliers")
}

model Category {
  id          String    @id @default(cuid())
  name        String
  nameArabic  String?
  description String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  // Relations
  products Product[]

  @@map("categories")
}

model Brand {
  id          String    @id @default(cuid())
  name        String
  nameArabic  String?
  description String?
  logoUrl     String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  // Relations
  products Product[]

  @@map("brands")
}

model Product {
  id            String      @id @default(cuid())
  name          String
  nameArabic    String?
  description   String?
  sku           String      @unique
  categoryId    String
  brandId       String?
  supplierId    String?
  type          ProductType @default(FINISHED)
  unit          ProductUnit @default(PIECE)
  unitPrice     Decimal     @db.Decimal(10, 2)
  costPrice     Decimal?    @db.Decimal(10, 2)
  stockQuantity Int         @default(0)
  minStock      Int         @default(0)
  maxStock      Int?
  isActive      Boolean     @default(true)
  hasVariants   Boolean     @default(false)
  imageUrl      String?
  notes         String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  createdById   String

  isVIPExclusive Boolean     @default(false)

  // Relations
  category       Category           @relation(fields: [categoryId], references: [id])
  brand          Brand?             @relation(fields: [brandId], references: [id])
  supplier       Supplier?          @relation(fields: [supplierId], references: [id])
  createdBy      User               @relation("CreatedBy", fields: [createdById], references: [id])
  orderItems     OrderItem[]
  stockMovements StockMovement[]
  productionBatches ProductionBatch[]
  storeInventory StoreInventory[]

  @@map("products")
}

// Store Management Models
model Store {
  id          String     @id @default(cuid())
  name        String
  nameArabic  String?
  code        String     @unique
  address     String
  emirate     String
  city        String
  phone       String?
  email       String?
  managerId   String?
  isActive    Boolean    @default(true)
  openingTime String?
  closingTime String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdById String

  // Relations
  createdBy       User             @relation("CreatedBy", fields: [createdById], references: [id])
  userStores      UserStore[]
  orders          Order[]
  inventory       StoreInventory[]
  fromTransfers   Transfer[]       @relation("FromStore")
  toTransfers     Transfer[]       @relation("ToStore")
  stockMovements  StockMovement[]

  @@map("stores")
}

model StoreInventory {
  id            String   @id @default(cuid())
  storeId       String
  productId     String
  quantity      Int      @default(0)
  reservedQty   Int      @default(0)
  lastUpdated   DateTime @default(now())

  // Relations
  store   Store   @relation(fields: [storeId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([storeId, productId])
  @@map("store_inventory")
}

model Transfer {
  id            String        @id @default(cuid())
  fromStoreId   String
  toStoreId     String
  status        TransferStatus @default(PENDING)
  notes         String?
  totalItems    Int           @default(0)
  requestedAt   DateTime      @default(now())
  approvedAt    DateTime?
  shippedAt     DateTime?
  receivedAt    DateTime?
  createdById   String

  // Relations
  fromStore     Store         @relation("FromStore", fields: [fromStoreId], references: [id])
  toStore       Store         @relation("ToStore", fields: [toStoreId], references: [id])
  createdBy     User          @relation("CreatedBy", fields: [createdById], references: [id])
  items         TransferItem[]

  @@map("transfers")
}

model TransferItem {
  id          String @id @default(cuid())
  transferId  String
  productId   String
  quantity    Int
  receivedQty Int?

  // Relations
  transfer Transfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product  Product  @relation(fields: [productId], references: [id])

  @@map("transfer_items")
}

// Sales & Order Models
model Order {
  id           String      @id @default(cuid())
  orderNumber  String      @unique
  customerId   String?
  storeId      String
  status       OrderStatus @default(PENDING)
  totalAmount  Decimal     @db.Decimal(10, 2)
  vatAmount    Decimal     @default(0) @db.Decimal(10, 2)
  grandTotal   Decimal     @db.Decimal(10, 2)
  paymentStatus PaymentStatus @default(PENDING)
  notes        String?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  createdById  String

  // Relations
  customer            Customer?                @relation(fields: [customerId], references: [id])
  store               Store                    @relation(fields: [storeId], references: [id])
  createdBy           User                     @relation("CreatedBy", fields: [createdById], references: [id])
  items               OrderItem[]
  payments            Payment[]
  complaints          CustomerComplaint[]
  loyaltyTransactions LoyaltyPointsTransaction[]
  giftCardTransactions GiftCardTransaction[]

  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  productId String
  quantity  Int
  unitPrice Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(10, 2)

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])

  @@map("order_items")
}

model Payment {
  id            String        @id @default(cuid())
  orderId       String?
  customerId    String?
  amount        Decimal       @db.Decimal(10, 2)
  method        PaymentMethod
  status        PaymentStatus @default(PENDING)
  reference     String?
  notes         String?
  createdAt     DateTime      @default(now())
  processedById String

  // Relations
  order       Order?    @relation(fields: [orderId], references: [id])
  customer    Customer? @relation(fields: [customerId], references: [id])
  processedBy User      @relation("ProcessedBy", fields: [processedById], references: [id])

  @@map("payments")
}

// Purchase Order Models
model PurchaseOrder {
  id           String             @id @default(cuid())
  orderNumber  String             @unique
  supplierId   String
  status       PurchaseOrderStatus @default(PENDING)
  totalAmount  Decimal            @db.Decimal(10, 2)
  notes        String?
  orderDate    DateTime           @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relations
  supplier Supplier            @relation(fields: [supplierId], references: [id])
  items    PurchaseOrderItem[]

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String  @id @default(cuid())
  purchaseOrderId String
  productId       String
  quantity        Int
  unitPrice       Decimal @db.Decimal(10, 2)
  receivedQty     Int     @default(0)

  // Relations
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id])

  @@map("purchase_order_items")
}

// Production Models
model Recipe {
  id            String    @id @default(cuid())
  name          String
  nameArabic    String?
  description   String?
  category      String?
  version       String    @default("1.0")
  isActive      Boolean   @default(true)
  yieldQuantity Decimal   @db.Decimal(10, 3)
  yieldUnit     String
  costPerUnit   Decimal?  @db.Decimal(10, 2)
  instructions  String?
  notes         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  ingredients       RecipeIngredient[]
  versions          RecipeVersion[]
  boms              BOM[]
  productionBatches ProductionBatch[]

  @@map("recipes")
}

model RecipeIngredient {
  id         String  @id @default(cuid())
  recipeId   String
  materialId String
  quantity   Decimal @db.Decimal(10, 3)
  unit       String
  percentage Decimal? @db.Decimal(5, 2)
  isOptional Boolean @default(false)
  notes      String?
  order      Int     @default(0)

  // Relations
  recipe   Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id])

  @@map("recipe_ingredients")
}

model RecipeVersion {
  id        String   @id @default(cuid())
  recipeId  String
  version   String
  changes   String?
  createdAt DateTime @default(now())
  createdBy String?

  // Relations
  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@map("recipe_versions")
}

model Material {
  id           String   @id @default(cuid())
  name         String
  description  String?
  sku          String   @unique
  categoryId   String
  unitOfMeasure String
  costPerUnit  Decimal  @db.Decimal(10, 2)
  currentStock Decimal  @db.Decimal(10, 3)
  minimumStock Decimal  @db.Decimal(10, 3)
  maximumStock Decimal? @db.Decimal(10, 3)
  supplier     String?
  supplierPrice Decimal? @db.Decimal(10, 2)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  category          Category           @relation(fields: [categoryId], references: [id])
  recipeIngredients RecipeIngredient[]
  bomItems          BOMItem[]
  productionInputs  ProductionInput[]
  productionOutputs ProductionOutput[]
  stockMovements    StockMovement[]
  wastageRecords    WastageRecord[]

  @@map("materials")
}

model BOM {
  id        String   @id @default(cuid())
  recipeId  String
  name      String
  version   String
  isActive  Boolean  @default(false)
  totalCost Decimal  @db.Decimal(10, 2)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recipe Recipe    @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  items  BOMItem[]

  @@map("boms")
}

model BOMItem {
  id         String  @id @default(cuid())
  bomId      String
  materialId String
  quantity   Decimal @db.Decimal(10, 3)
  unit       String
  unitCost   Decimal @db.Decimal(10, 2)
  totalCost  Decimal @db.Decimal(10, 2)
  notes      String?

  // Relations
  bom      BOM      @relation(fields: [bomId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id])

  @@map("bom_items")
}

model ProductionBatch {
  id                String           @id @default(cuid())
  batchNumber       String           @unique
  recipeId          String?
  plannedQuantity   Decimal          @db.Decimal(10, 3)
  actualQuantity    Decimal?         @db.Decimal(10, 3)
  unit              String
  status            ProductionStatus @default(PLANNED)
  startDate         DateTime
  endDate           DateTime?
  agingStartDate    DateTime?
  agingEndDate      DateTime?
  agingDays         Int?
  temperature       Decimal?         @db.Decimal(5, 2)
  humidity          Decimal?         @db.Decimal(5, 2)
  notes             String?
  supervisorId      String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  recipe          Recipe?            @relation(fields: [recipeId], references: [id])
  supervisor      User?              @relation("SupervisedBy", fields: [supervisorId], references: [id])
  inputs          ProductionInput[]
  outputs         ProductionOutput[]
  qualityControls QualityControl[]
  wastageRecords  WastageRecord[]
  processingStages ProcessingStage[]

  @@map("production_batches")
}

model ProductionInput {
  id               String   @id @default(cuid())
  batchId          String
  materialId       String
  plannedQuantity  Decimal  @db.Decimal(10, 3)
  actualQuantity   Decimal? @db.Decimal(10, 3)
  unit             String
  costPerUnit      Decimal  @db.Decimal(10, 2)
  totalCost        Decimal  @db.Decimal(10, 2)
  notes            String?
  createdAt        DateTime @default(now())

  // Relations
  batch    ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material        @relation(fields: [materialId], references: [id])

  @@map("production_inputs")
}

model ProductionOutput {
  id          String   @id @default(cuid())
  batchId     String
  materialId  String
  quantity    Decimal  @db.Decimal(10, 3)
  unit        String
  costPerUnit Decimal  @db.Decimal(10, 2)
  totalCost   Decimal  @db.Decimal(10, 2)
  notes       String?
  createdAt   DateTime @default(now())

  // Relations
  batch    ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material        @relation(fields: [materialId], references: [id])

  @@map("production_outputs")
}

model QualityControl {
  id        String        @id @default(cuid())
  batchId   String
  testType  String
  testDate  DateTime
  result    QualityResult @default(PENDING)
  score     Decimal?      @db.Decimal(3, 1)
  notes     String?
  testedBy  String?
  images    String?       // JSON array of image URLs
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Relations
  batch ProductionBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@map("quality_controls")
}

model WastageRecord {
  id         String   @id @default(cuid())
  batchId    String?
  materialId String?
  quantity   Decimal  @db.Decimal(10, 3)
  unit       String
  reason     String
  cost       Decimal  @db.Decimal(10, 2)
  recordedAt DateTime
  notes      String?
  createdAt  DateTime @default(now())

  // Relations
  batch    ProductionBatch? @relation(fields: [batchId], references: [id], onDelete: Cascade)
  material Material?        @relation(fields: [materialId], references: [id])

  @@map("wastage_records")
}

model ProcessingStage {
  id                String      @id @default(cuid())
  productionBatchId String
  stageName         String
  description       String?
  order             Int         @default(0)
  status            StageStatus @default(PENDING)
  startedAt         DateTime?
  completedAt       DateTime?
  temperature       Decimal?    @db.Decimal(5, 2)
  humidity          Decimal?    @db.Decimal(5, 2)
  duration          Int?        // in minutes
  instructions      String?
  notes             String?
  operatorId        String?
  isRequired        Boolean     @default(true)
  isIoTEnabled      Boolean     @default(false)
  sensorData        String?     // JSON for IoT sensor readings

  // Relations
  productionBatch ProductionBatch @relation(fields: [productionBatchId], references: [id], onDelete: Cascade)
  operator        User?           @relation("OperatedBy", fields: [operatorId], references: [id])

  @@map("processing_stages")
}

// Inventory Management
model StockMovement {
  id            String            @id @default(cuid())
  productId     String
  storeId       String?
  movementType  StockMovementType
  quantity      Int
  referenceType String?           // ORDER, ADJUSTMENT, TRANSFER, etc.
  referenceId   String?
  notes         String?
  createdAt     DateTime          @default(now())
  createdById   String

  // Relations
  product   Product @relation(fields: [productId], references: [id])
  store     Store?  @relation(fields: [storeId], references: [id])
  createdBy User    @relation("CreatedBy", fields: [createdById], references: [id])

  @@map("stock_movements")
}

// Enums
enum UserRole {
  SUPER_ADMIN           // Owner / Head Office - Full control
  ADMIN                 // Branch Manager - Manage assigned store
  SALES_STAFF           // POS User - Daily sales operations
  INVENTORY_STAFF       // Warehouse Staff - Stock management
  PRODUCTION_STAFF      // Lab/Production - Batch management
  PROCUREMENT_OFFICER   // Purchase Officer - Supplier & PO management
  ACCOUNTANT            // Finance & Accounts - Financial operations
  HR_MANAGER            // HR - Staff, payroll, attendance
  EVENT_STAFF           // Temporary location/exhibition POS
  EVENT_MANAGER         // Event Manager - Event profitability
  AUDITOR               // Read-only access for compliance
  MANAGER               // Legacy - Branch operations
  OWNER                 // Legacy - Kept for backwards compatibility
  USER                  // Basic user
}

enum StoreRole {
  MANAGER
  ASSISTANT_MANAGER
  SALES_STAFF
  INVENTORY_STAFF
}

enum CustomerType {
  INDIVIDUAL
  CORPORATE
}

enum ProductType {
  RAW_MATERIAL
  SEMI_FINISHED
  FINISHED
}

enum ProductUnit {
  PIECE
  GRAM
  KILOGRAM
  TOLA
  MILLILITER
  LITER
  BOTTLE
  SET
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
}

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CARD
  BANK_TRANSFER
  DIGITAL_WALLET
  CHEQUE
}

enum PurchaseOrderStatus {
  PENDING
  CONFIRMED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

enum TransferStatus {
  PENDING
  APPROVED
  SHIPPED
  RECEIVED
  CANCELLED
}

enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  AGING
  QUALITY_CHECK
  COMPLETED
  CANCELLED
  ON_HOLD
}

enum QualityResult {
  PENDING
  PASS
  FAIL
  RETEST_REQUIRED
}

enum StageStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

enum StockMovementType {
  IN
  OUT
  ADJUSTMENT
  TRANSFER
}

// CRM & Marketing Models
model MarketingCampaign {
  id            String         @id @default(cuid())
  name          String
  description   String?        @db.Text
  type          CampaignType
  targetSegment String?
  startDate     DateTime
  endDate       DateTime
  budget        Decimal?       @db.Decimal(15, 2)
  status        CampaignStatus @default(DRAFT)
  createdBy     String
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // Relations
  segment   CustomerSegment?     @relation(fields: [targetSegment], references: [id])
  messages  CampaignMessage[]
  responses CampaignResponse[]

  @@map("marketing_campaigns")
}

model CampaignMessage {
  id         String   @id @default(cuid())
  campaignId String
  subject    String
  body       String   @db.Text
  sentAt     DateTime @default(now())

  // Relations
  campaign MarketingCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@map("campaign_messages")
}

model CampaignResponse {
  id         String   @id @default(cuid())
  campaignId String
  customerId String
  responseType String  // OPENED, CLICKED, CONVERTED
  createdAt  DateTime @default(now())

  // Relations
  campaign MarketingCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  customer Customer          @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@map("campaign_responses")
}

model CustomerSegment {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  type        SegmentType
  criteria    Json?
  isActive    Boolean  @default(true)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  campaigns MarketingCampaign[]
  customers CustomerSegmentMember[]

  @@map("customer_segments")
}

model CustomerSegmentMember {
  id         String   @id @default(cuid())
  segmentId  String
  customerId String
  addedAt    DateTime @default(now())

  // Relations
  segment  CustomerSegment @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  customer Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([segmentId, customerId])
  @@map("customer_segment_members")
}

model CustomerComplaint {
  id          String           @id @default(cuid())
  customerId  String
  orderId     String?
  subject     String
  description String           @db.Text
  priority    ComplaintPriority @default(MEDIUM)
  category    ComplaintCategory @default(OTHER)
  status      ComplaintStatus   @default(OPEN)
  assignedTo  String?
  resolution  String?          @db.Text
  createdBy   String
  createdAt   DateTime         @default(now())
  resolvedAt  DateTime?
  updatedAt   DateTime         @updatedAt

  // Relations
  customer   Customer @relation(fields: [customerId], references: [id])
  order      Order?   @relation(fields: [orderId], references: [id])
  assignedUser User?  @relation("AssignedComplaints", fields: [assignedTo], references: [id])

  @@map("customer_complaints")
}

// Loyalty & VIP Models
model LoyaltyPointsTransaction {
  id          String              @id @default(cuid())
  customerId  String
  points      Int
  type        LoyaltyTransactionType
  orderId     String?
  description String?
  expiryDate  DateTime?
  createdBy   String
  createdAt   DateTime            @default(now())

  // Relations
  customer Customer @relation(fields: [customerId], references: [id])
  order    Order?   @relation(fields: [orderId], references: [id])

  @@map("loyalty_points_transactions")
}

model VIPEvent {
  id            String   @id @default(cuid())
  name          String
  description   String?  @db.Text
  eventDate     DateTime
  location      String?
  maxAttendees  Int?
  isExclusive   Boolean  @default(true)
  minimumTier   String?
  createdBy     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  attendees VIPEventAttendee[]

  @@map("vip_events")
}

model VIPEventAttendee {
  id         String   @id @default(cuid())
  eventId    String
  customerId String
  registeredAt DateTime @default(now())
  attended   Boolean  @default(false)

  // Relations
  event    VIPEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id])

  @@unique([eventId, customerId])
  @@map("vip_event_attendees")
}

// Finance & Accounting Models
model VATReturn {
  id             String         @id @default(cuid())
  periodStart    DateTime
  periodEnd      DateTime
  totalSales     Decimal        @db.Decimal(15, 2)
  totalPurchases Decimal        @db.Decimal(15, 2)
  outputVAT      Decimal        @db.Decimal(15, 2)
  inputVAT       Decimal        @db.Decimal(15, 2)
  netVAT         Decimal        @db.Decimal(15, 2)
  status         VATReturnStatus @default(DRAFT)
  submittedAt    DateTime?
  paidAt         DateTime?
  createdBy      String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@map("vat_returns")
}

model BankAccount {
  id            String   @id @default(cuid())
  accountName   String
  accountNumber String   @unique
  bankName      String
  branch        String?
  currency      String   @default("AED")
  balance       Decimal  @db.Decimal(15, 2) @default(0)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  transactions     BankTransaction[]
  reconciliations  BankReconciliation[]

  @@map("bank_accounts")
}

model BankTransaction {
  id               String    @id @default(cuid())
  bankAccountId    String
  transactionDate  DateTime
  description      String
  reference        String?
  amount           Decimal   @db.Decimal(15, 2)
  type             TransactionType
  balance          Decimal?  @db.Decimal(15, 2)
  isReconciled     Boolean   @default(false)
  reconciliationId String?
  createdAt        DateTime  @default(now())

  // Relations
  bankAccount    BankAccount         @relation(fields: [bankAccountId], references: [id])
  reconciliation BankReconciliation? @relation(fields: [reconciliationId], references: [id])

  @@map("bank_transactions")
}

model BankReconciliation {
  id               String              @id @default(cuid())
  bankAccountId    String
  statementDate    DateTime
  statementBalance Decimal             @db.Decimal(15, 2)
  bookBalance      Decimal             @db.Decimal(15, 2)
  difference       Decimal             @db.Decimal(15, 2)
  status           ReconciliationStatus @default(PENDING)
  createdBy        String
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  // Relations
  bankAccount  BankAccount       @relation(fields: [bankAccountId], references: [id])
  transactions BankTransaction[]

  @@map("bank_reconciliations")
}

// HR & Payroll Models
model Employee {
  id             String   @id @default(cuid())
  userId         String   @unique
  employeeCode   String   @unique
  department     String?
  position       String?
  hireDate       DateTime
  basicSalary    Decimal  @db.Decimal(10, 2)
  allowances     Decimal? @db.Decimal(10, 2)
  deductions     Decimal? @db.Decimal(10, 2)
  commissionRate Decimal? @db.Decimal(5, 2)
  hourlyRate     Decimal? @db.Decimal(10, 2)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  payrolls    Payroll[]
  attendances Attendance[]
  leaves      Leave[]

  @@map("employees")
}

model Payroll {
  id          String        @id @default(cuid())
  employeeId  String
  periodStart DateTime
  periodEnd   DateTime
  basicSalary Decimal       @db.Decimal(10, 2)
  allowances  Decimal       @db.Decimal(10, 2) @default(0)
  deductions  Decimal       @db.Decimal(10, 2) @default(0)
  commission  Decimal       @db.Decimal(10, 2) @default(0)
  overtime    Decimal       @db.Decimal(10, 2) @default(0)
  grossSalary Decimal       @db.Decimal(10, 2)
  netSalary   Decimal       @db.Decimal(10, 2)
  status      PayrollStatus @default(PENDING)
  paidAt      DateTime?
  createdBy   String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  employee Employee @relation(fields: [employeeId], references: [id])

  @@map("payroll")
}

model Attendance {
  id            String    @id @default(cuid())
  employeeId    String
  date          DateTime  @db.Date
  checkIn       DateTime?
  checkOut      DateTime?
  hoursWorked   Decimal?  @db.Decimal(4, 2)
  overtimeHours Decimal?  @db.Decimal(4, 2)
  status        AttendanceStatus @default(PRESENT)
  notes         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  employee Employee @relation(fields: [employeeId], references: [id])

  @@unique([employeeId, date])
  @@map("attendance")
}

model Leave {
  id          String      @id @default(cuid())
  employeeId  String
  leaveType   LeaveType
  startDate   DateTime    @db.Date
  endDate     DateTime    @db.Date
  days        Int
  reason      String?     @db.Text
  status      LeaveStatus @default(PENDING)
  approvedBy  String?
  approvedAt  DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  employee Employee @relation(fields: [employeeId], references: [id])

  @@map("leaves")
}

// Sales & Promotions Models
model GiftCard {
  id           String          @id @default(cuid())
  code         String          @unique
  initialValue Decimal         @db.Decimal(10, 2)
  balance      Decimal         @db.Decimal(10, 2)
  currency     String          @default("AED")
  issuedTo     String?
  issuedDate   DateTime        @default(now())
  expiryDate   DateTime?
  status       GiftCardStatus  @default(ACTIVE)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Relations
  transactions GiftCardTransaction[]

  @@map("gift_cards")
}

model GiftCardTransaction {
  id          String   @id @default(cuid())
  giftCardId  String
  orderId     String?
  amount      Decimal  @db.Decimal(10, 2)
  type        TransactionType
  description String?
  createdAt   DateTime @default(now())

  // Relations
  giftCard GiftCard @relation(fields: [giftCardId], references: [id])
  order    Order?   @relation(fields: [orderId], references: [id])

  @@map("gift_card_transactions")
}

model Discount {
  id            String        @id @default(cuid())
  code          String        @unique
  name          String
  description   String?       @db.Text
  type          DiscountType
  value         Decimal       @db.Decimal(10, 2)
  minPurchase   Decimal?      @db.Decimal(10, 2)
  maxDiscount   Decimal?      @db.Decimal(10, 2)
  startDate     DateTime
  endDate       DateTime
  usageLimit    Int?
  usageCount    Int           @default(0)
  isActive      Boolean       @default(true)
  applicableTo  Json?         // Product IDs, categories, etc.
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@map("discounts")
}

model Promotion {
  id          String         @id @default(cuid())
  name        String
  description String?        @db.Text
  type        PromotionType
  conditions  Json           // Buy X Get Y, Spend amount get discount, etc.
  rewards     Json           // What customer gets
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean        @default(true)
  priority    Int            @default(0)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@map("promotions")
}

// Additional Enums
enum CampaignType {
  EMAIL
  SMS
  WHATSAPP
  PUSH_NOTIFICATION
  MULTI_CHANNEL
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum SegmentType {
  VIP
  REGULAR
  CORPORATE
  RETAIL
  WHOLESALE
  CUSTOM
}

enum ComplaintPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ComplaintCategory {
  PRODUCT_QUALITY
  DELIVERY
  SERVICE
  PRICING
  OTHER
}

enum ComplaintStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum LoyaltyTransactionType {
  EARNED
  REDEEMED
  EXPIRED
  ADJUSTED
}

enum VATReturnStatus {
  DRAFT
  SUBMITTED
  PAID
}

enum TransactionType {
  DEBIT
  CREDIT
}

enum ReconciliationStatus {
  PENDING
  RECONCILED
  DISCREPANCY
}

enum PayrollStatus {
  PENDING
  APPROVED
  PAID
  CANCELLED
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  HALF_DAY
  LEAVE
}

enum LeaveType {
  ANNUAL
  SICK
  EMERGENCY
  UNPAID
  MATERNITY
  PATERNITY
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum GiftCardStatus {
  ACTIVE
  USED
  EXPIRED
  CANCELLED
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_SHIPPING
}

enum PromotionType {
  BUY_X_GET_Y
  SPEND_GET_DISCOUNT
  BUNDLE_DEAL
  FLASH_SALE
}

// Sampling & Trial Management Models
model SamplingSession {
  id                String           @id @default(cuid())
  sessionNumber     String           @unique
  customerId        String?
  customerName      String?
  customerPhone     String?
  customerEmail     String?
  customerType      String?          // walk-in, returning, vip
  isAnonymous       Boolean          @default(false)
  storeId           String
  staffId           String
  outcome           SamplingOutcome
  saleAmount        Decimal?         @db.Decimal(10, 2)
  notPurchaseReason String?
  notes             String?          @db.Text
  totalTesterCost   Decimal          @db.Decimal(10, 2)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  customer       Customer?           @relation(fields: [customerId], references: [id])
  store          Store               @relation(fields: [storeId], references: [id])
  staff          User                @relation("SamplingStaff", fields: [staffId], references: [id])
  testedProducts SamplingProduct[]

  @@map("sampling_sessions")
}

model SamplingProduct {
  id            String   @id @default(cuid())
  sessionId     String
  productId     String
  productName   String
  productCode   String
  productType   String   // perfume, oud, attar
  quantityUsed  Decimal  @db.Decimal(10, 3)
  unit          String
  costPerUnit   Decimal  @db.Decimal(10, 2)
  totalCost     Decimal  @db.Decimal(10, 2)
  createdAt     DateTime @default(now())

  // Relations
  session SamplingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  product Product         @relation(fields: [productId], references: [id])

  @@map("sampling_products")
}

model TesterStock {
  id               String   @id @default(cuid())
  productId        String   @unique
  currentStock     Decimal  @db.Decimal(10, 3)
  minLevel         Decimal  @db.Decimal(10, 3)
  unit             String
  lastRefillDate   DateTime?
  lastRefillAmount Decimal? @db.Decimal(10, 3)
  monthlyUsage     Decimal  @db.Decimal(10, 3) @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id])

  @@map("tester_stock")
}

model TesterRefill {
  id          String           @id @default(cuid())
  productId   String
  quantity    Decimal          @db.Decimal(10, 3)
  unit        String
  sourceType  TesterSourceType
  cost        Decimal          @db.Decimal(10, 2)
  refilledBy  String
  notes       String?
  createdAt   DateTime         @default(now())

  // Relations
  product    Product @relation(fields: [productId], references: [id])
  refilledByUser User @relation("TesterRefilledBy", fields: [refilledBy], references: [id])

  @@map("tester_refills")
}

enum SamplingOutcome {
  PURCHASED
  NOT_PURCHASED
}

enum TesterSourceType {
  MAIN_INVENTORY
  PURCHASE
}