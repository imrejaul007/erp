import { NextRequest } from 'next/server';
import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { withTenant } from '@/lib/with-tenant';
import { apiResponse, apiError } from '@/lib/api-response';

const AutoGenerateSchema = z.object({
  orderId: z.string().optional(),
  batchId: z.string().optional(),
  productId: z.string().optional(),
  recipeId: z.string().optional(),
  type: z.enum(['PRODUCTION', 'MAINTENANCE', 'QUALITY_CHECK', 'REWORK', 'ASSEMBLY', 'PACKAGING', 'TESTING', 'CUSTOM']).default('PRODUCTION'),
  priority: z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'SCHEDULED']).default('MEDIUM'),
  autoSchedule: z.boolean().default(true),
});

/**
 * POST /api/work-orders/auto-generate - Auto-generate work orders
 */
export const POST = withTenant(async (req: NextRequest, { tenantId, user }) => {
  try {
    const body = await req.json();
    const validated = AutoGenerateSchema.parse(body);

    let workOrders: any[] = [];

    // Generate from order
    if (validated.orderId) {
      const order = await prisma.order.findFirst({
        where: { id: validated.orderId, tenantId },
        include: {
          items: {
            include: {
              product: true,
            },
          },
        },
      });

      if (!order) {
        return apiError('Order not found', 404);
      }

      // Create work order for each order item
      for (const item of order.items) {
        const count = await prisma.workOrder.count({ where: { tenantId } });
        const workOrderNumber = `WO-${String(count + workOrders.length + 1).padStart(6, '0')}`;

        const scheduledStart = new Date();
        const scheduledEnd = new Date(scheduledStart.getTime() + 24 * 60 * 60 * 1000); // +1 day

        const workOrder = await prisma.workOrder.create({
          data: {
            workOrderNumber,
            title: `Production: ${item.product.name} for Order ${order.orderNumber}`,
            type: validated.type,
            priority: validated.priority,
            productId: item.productId,
            orderId: validated.orderId,
            quantity: item.quantity,
            unit: item.product.unit || 'pcs',
            scheduledStart,
            scheduledEnd,
            autoGenerated: true,
            autoScheduled: validated.autoSchedule,
            tenantId,
          },
          include: {
            product: true,
            order: true,
          },
        });

        workOrders.push(workOrder);
      }
    }

    // Generate from production batch
    if (validated.batchId) {
      const batch = await prisma.productionBatch.findFirst({
        where: { id: validated.batchId, tenantId },
        include: {
          recipe: true,
        },
      });

      if (!batch) {
        return apiError('Production batch not found', 404);
      }

      const count = await prisma.workOrder.count({ where: { tenantId } });
      const workOrderNumber = `WO-${String(count + workOrders.length + 1).padStart(6, '0')}`;

      const workOrder = await prisma.workOrder.create({
        data: {
          workOrderNumber,
          title: `Production Batch ${batch.batchNumber}`,
          type: validated.type,
          priority: validated.priority,
          recipeId: batch.recipeId || undefined,
          batchId: validated.batchId,
          quantity: batch.plannedQuantity,
          unit: batch.unit,
          scheduledStart: batch.startDate,
          scheduledEnd: batch.endDate || new Date(batch.startDate.getTime() + 7 * 24 * 60 * 60 * 1000),
          autoGenerated: true,
          autoScheduled: validated.autoSchedule,
          tenantId,
        },
        include: {
          recipe: true,
          batch: true,
        },
      });

      workOrders.push(workOrder);
    }

    // Generate from product/recipe
    if (validated.productId || validated.recipeId) {
      const count = await prisma.workOrder.count({ where: { tenantId } });
      const workOrderNumber = `WO-${String(count + workOrders.length + 1).padStart(6, '0')}`;

      let product, recipe;

      if (validated.productId) {
        product = await prisma.products.findFirst({
          where: { id: validated.productId, tenantId },
        });
      }

      if (validated.recipeId) {
        recipe = await prisma.recipe.findFirst({
          where: { id: validated.recipeId, tenantId },
        });
      }

      const scheduledStart = new Date();
      const scheduledEnd = new Date(scheduledStart.getTime() + 24 * 60 * 60 * 1000);

      const workOrder = await prisma.workOrder.create({
        data: {
          workOrderNumber,
          title: `${validated.type}: ${product?.name || recipe?.name || 'Custom Work Order'}`,
          type: validated.type,
          priority: validated.priority,
          productId: validated.productId,
          recipeId: validated.recipeId,
          quantity: 1,
          unit: product?.unit || 'pcs',
          scheduledStart,
          scheduledEnd,
          autoGenerated: true,
          autoScheduled: validated.autoSchedule,
          tenantId,
        },
        include: {
          product: true,
          recipe: true,
        },
      });

      workOrders.push(workOrder);
    }

    if (workOrders.length === 0) {
      return apiError('No work orders generated. Please provide orderId, batchId, productId, or recipeId', 400);
    }

    return apiResponse({
      message: `${workOrders.length} work order(s) auto-generated successfully`,
      workOrders,
    }, 201);
  } catch (error: any) {
    console.error('Error auto-generating work orders:', error);
    if (error instanceof z.ZodError) {
      return apiError(error.errors[0].message, 400);
    }
    return apiError(error.message || 'Failed to auto-generate work orders', 500);
  }
});
